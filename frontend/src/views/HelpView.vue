<template>
  <div class="help-view">
    <el-card class="help-card">
      <template #header>
        <div class="help-header">
          <h1>Руководство пользователя по методам предобработки данных</h1>
          <el-button @click="scrollToTop" circle icon="el-icon-top" 
            v-if="showScrollTop" />
        </div>
      </template>
      
      <div class="table-of-contents">
        <h2>Содержание</h2>
        <el-menu 
          :default-active="activeSection" 
          class="toc-menu" 
          @select="scrollToSection"
        >
          <el-menu-item v-for="section in sections" :key="section.id" :index="section.id">
            {{ section.title }}
          </el-menu-item>
        </el-menu>
      </div>
      
      <div class="help-content" ref="contentRef" v-html="renderedContent"></div>
      
      <div class="feedback-container">
        <h3>Была ли эта информация полезной?</h3>
        <div class="feedback-buttons">
          <el-button type="success" icon="el-icon-check" @click="provideFeedback(true)">Да, спасибо!</el-button>
          <el-button type="info" icon="el-icon-message" @click="showFeedbackForm = true">У меня есть предложения</el-button>
        </div>
      </div>

      <el-dialog
        title="Ваше мнение важно для нас"
        v-model="showFeedbackForm"
        width="50%"
      >
        <el-form :model="feedbackForm">
          <el-form-item label="Какой раздел нуждается в улучшении?">
            <el-select v-model="feedbackForm.section" placeholder="Выберите раздел">
              <el-option
                v-for="section in sections"
                :key="section.id"
                :label="section.title"
                :value="section.id"
              ></el-option>
            </el-select>
          </el-form-item>
          <el-form-item label="Ваши предложения">
            <el-input
              type="textarea"
              v-model="feedbackForm.message"
              :rows="5"
              placeholder="Опишите, какую информацию следует добавить или изменить"
            ></el-input>
          </el-form-item>
        </el-form>
        <template #footer>
          <span class="dialog-footer">
            <el-button @click="showFeedbackForm = false">Отмена</el-button>
            <el-button type="primary" @click="submitFeedback">Отправить</el-button>
          </span>
        </template>
      </el-dialog>
    </el-card>
  </div>
</template>

<script>
import { defineComponent, ref, reactive, onMounted, onUnmounted } from 'vue';
import { marked } from 'marked';
import { ElMessage } from 'element-plus';

export default defineComponent({
  name: 'HelpView',
  
  setup() {
    const markdownContent = `
# Руководство пользователя по методам предобработки данных

<a id="introduction"></a>
## Введение
Данное приложение предоставляет удобный конструктор для предобработки данных перед построением прогнозных моделей. В этом руководстве описаны доступные методы преобразования данных, их назначение, принципы работы и примеры применения.

<a id="toc"></a>
## Содержание
1. [Обработка пропущенных значений](#missing-values)
2. [Обработка выбросов](#outliers)
3. [Стандартизация данных](#standardization)
4. [Кодирование категориальных переменных](#categorical-encoding)
5. [Снижение размерности (PCA)](#pca)
6. [Лагирование переменных](#lagging)
7. [Скользящие статистики](#rolling-statistics)
8. [Извлечение компонентов даты](#date-components)
9. [Обратное масштабирование](#inverse-scaling)
10. [Рекомендуемые последовательности методов](#recommended-sequence)
11. [Часто задаваемые вопросы](#faq)

<a id="missing-values"></a>
## 1. Обработка пропущенных значений

### Описание
Метод используется для обработки отсутствующих данных (NA, NULL) в наборе данных. Пропущенные значения могут искажать результаты анализа или делать невозможным применение некоторых алгоритмов.

### Параметры
- **Стратегия обработки**: 
  - *Заполнить средним* - заполняет пропуски средним значением по столбцу
  - *Заполнить медианой* - заполняет пропуски медианным значением (более устойчиво к выбросам)
  - *Заполнить модой* - заполняет пропуски наиболее часто встречающимся значением
  - *Удалить строки* - удаляет строки, содержащие пропущенные значения

- **Столбцы для обработки**: выберите столбцы, в которых нужно обработать пропуски

### Пример
Исходные данные:
\`\`\`
id | Доход   | Возраст
---|---------|--------
1  | 50000   | 35
2  | [NULL]  | 42
3  | 75000   | 28
4  | 62000   | [NULL]
5  | [NULL]  | 39
\`\`\`

При применении стратегии "Заполнить средним" для столбца "Доход", результат будет:
\`\`\`
id | Доход   | Возраст
---|---------|--------
1  | 50000   | 35
2  | 62333   | 42   // Среднее от 50000, 75000 и 62000
3  | 75000   | 28
4  | 62000   | [NULL]
5  | 62333   | 39   // Среднее от 50000, 75000 и 62000
\`\`\`

### Когда применять
- Когда в данных есть пропуски, которые могут мешать анализу
- Когда используемые алгоритмы не поддерживают работу с пропущенными данными
- Перед применением методов моделирования, требующих полные данные

### Особенности
- Заполнение средним подходит для нормально распределенных данных
- Заполнение медианой лучше для данных с выбросами
- Заполнение модой предпочтительно для категориальных данных
- Удаление строк может быть опасно при большом количестве пропусков, так как это значительно уменьшает объем данных

<a id="outliers"></a>
## 2. Обработка выбросов

### Описание
Выбросы - это аномальные значения, которые значительно отличаются от большинства наблюдений. Они могут искажать статистические показатели и снижать качество моделей.

### Параметры
- **Метод обнаружения выбросов**:
  - *Z-оценка* - определяет выбросы на основе стандартного отклонения от среднего
  - *Межквартильный размах (IQR)* - использует разницу между 1-м и 3-м квартилями для обнаружения выбросов

- **Порог для определения выбросов**: 
  - Для Z-оценки: значения, превышающие среднее на указанное число стандартных отклонений
  - Для IQR: значения, выходящие за пределы Q1-порог×IQR и Q3+порог×IQR

- **Столбцы для обработки**: выберите числовые столбцы для обнаружения выбросов

### Пример
Рассмотрим данные о возрасте клиентов:
\`\`\`
[25, 30, 35, 28, 32, 27, 29, 31, 26, 150]
\`\`\`

Применение метода Z-оценки:
1. Среднее: 41.3
2. Стандартное отклонение: 38.85
3. Z-оценка для 150: (150 - 41.3) / 38.85 = 2.8
4. При пороге 2.5, значение 150 считается выбросом

После обработки выбросов получим:
\`\`\`
[25, 30, 35, 28, 32, 27, 29, 31, 26, 41.3] // заменили на среднее
или
[25, 30, 35, 28, 32, 27, 29, 31, 26] // удалили выброс
\`\`\`

### Когда применять
- При наличии аномальных значений, искажающих статистику
- Перед обучением моделей, чувствительных к выбросам (например, линейная регрессия)
- Для повышения устойчивости и обобщающей способности моделей

<a id="standardization"></a>
## 3. Стандартизация данных

### Описание
Стандартизация приводит признаки к единому масштабу, что особенно важно для алгоритмов, чувствительных к масштабу данных. Это помогает предотвратить доминирование переменных с большими значениями над переменными с малыми значениями.

### Параметры
- **Метод стандартизации**:
  - *Стандартизация* - преобразует данные так, чтобы среднее значение было 0, а стандартное отклонение - 1
  - *Мин-макс нормализация* - масштабирует данные в диапазон [0, 1]

- **Столбцы для обработки**: выберите числовые столбцы для стандартизации

### Пример
Исходные данные в столбце "Доход": [10000, 20000, 30000, 40000, 50000]

Применение стандартизации:
1. Среднее: 30000
2. Стандартное отклонение: 15811
3. После стандартизации: [-1.27, -0.63, 0, 0.63, 1.27]

Применение мин-макс нормализации:
1. Минимум: 10000
2. Максимум: 50000
3. После нормализации: [0, 0.25, 0.5, 0.75, 1]

### Когда применять
- Перед использованием алгоритмов, чувствительных к масштабу (метод k-ближайших соседей, метод опорных векторов, нейронные сети)
- Когда признаки имеют разные единицы измерения и диапазоны значений
- Для улучшения сходимости градиентных методов

<a id="categorical-encoding"></a>
## 4. Кодирование категориальных переменных

### Описание
Преобразует категориальные (текстовые или символьные) данные в числовой формат, необходимый для большинства алгоритмов машинного обучения. Это позволяет включить категориальные признаки в модели, требующие числовых входных данных.

### Параметры
- **Метод кодирования**:
  - *One-Hot кодирование* - создает бинарные столбцы для каждой категории
  - *Label кодирование* - присваивает категориям числовые метки

- **Столбцы для обработки**: категориальные столбцы для кодирования

### Пример
Исходные данные в столбце "Город": ["Москва", "Санкт-Петербург", "Москва", "Казань"]

**One-Hot кодирование:**
\`\`\`
Город_Москва: [1, 0, 1, 0]
Город_Санкт-Петербург: [0, 1, 0, 0]
Город_Казань: [0, 0, 0, 1]
\`\`\`

**Label кодирование:**
\`\`\`
Город: [0, 1, 0, 2]
\`\`\`

### Когда применять
- Для категориальных данных перед использованием алгоритмов, требующих числовые входные данные
- One-Hot для номинальных переменных (без естественного порядка)
- Label для порядковых переменных (с естественным порядком)

### Сравнение методов

**One-Hot кодирование:**
- Создает бинарные признаки для каждой категории
- Не вводит искусственный порядок между категориями
- Увеличивает размерность данных
- Хорошо работает для категорий без иерархии

**Label кодирование:**
- Заменяет категории числовыми метками
- Может внести нежелательный порядок между категориями
- Сохраняет исходную размерность данных
- Лучше для порядковых переменных (например, "низкий", "средний", "высокий")

<a id="pca"></a>
## 5. Снижение размерности (PCA)

### Описание
Метод главных компонент (PCA) уменьшает количество признаков за счет создания новых, являющихся линейными комбинациями исходных переменных. Это позволяет снизить размерность данных с минимальной потерей информации.

### Параметры
- **Количество компонент**: число новых признаков, которые будут созданы
- **Столбцы для обработки**: числовые столбцы для преобразования

### Пример
Предположим, у нас есть данные с 5 исходными признаками, сильно коррелирующими между собой.

Шаги PCA:
1. Стандартизация данных
2. Вычисление ковариационной матрицы
3. Вычисление собственных векторов и собственных значений
4. Сортировка собственных векторов по убыванию собственных значений
5. Выбор первых k собственных векторов для формирования пространства меньшей размерности
6. Проекция исходных данных на новое пространство

В результате получаем 2-3 главные компоненты, сохраняющие, например, 95% вариативности исходных данных.

### Когда применять
- Когда данные содержат много признаков, которые коррелируют между собой
- Для сокращения размерности данных и устранения мультиколлинеарности
- При визуализации многомерных данных в двумерном или трехмерном пространстве
- Для ускорения обучения моделей путем сокращения числа входных признаков

<a id="lagging"></a>
## 6. Лагирование переменных

### Описание
Создает новые признаки на основе предыдущих значений временного ряда. Это помогает алгоритмам машинного обучения улавливать временные зависимости и учитывать исторические данные при прогнозировании будущих значений.

### Параметры
- **Целевая переменная**: временной ряд, для которого нужно создать лаги
- **Периоды лагирования**: на сколько шагов назад смещать значения (например, 1, 2, 3 дня)
- **Экзогенные переменные для лагирования**: другие временные ряды, которые могут влиять на целевую переменную

### Пример
Если у вас есть временной ряд цен акций, и вы хотите предсказать цену на следующий день, вы можете создать лаги для 1, 2 и 3 дней:

\`\`\`
Дата       | Цена | Цена_lag_1 | Цена_lag_2 | Цена_lag_3
-----------|------|------------|------------|------------
01.01.2023 | 100  | NULL       | NULL       | NULL
02.01.2023 | 102  | 100        | NULL       | NULL
03.01.2023 | 101  | 102        | 100        | NULL
04.01.2023 | 103  | 101        | 102        | 100
05.01.2023 | 105  | 103        | 101        | 102
\`\`\`

### Когда применять
- При анализе и прогнозировании временных рядов
- Для учета предыдущих значений при предсказании будущих
- Когда текущее значение переменной зависит от её прошлых значений
- Для выявления сезонных паттернов и циклов

<a id="rolling-statistics"></a>
## 7. Скользящие статистики

### Описание
Рассчитывает различные статистические показатели (среднее, стандартное отклонение и др.) в скользящем окне фиксированного размера для временных рядов. Это позволяет учитывать локальные тренды и сглаживать шумы в данных.

### Параметры
- **Целевая переменная**: временной ряд для расчета статистик
- **Размер окна**: количество наблюдений в окне (например, 3, 7, 30)
- **Статистики для расчета**: показатели для вычисления (среднее, стандартное отклонение, минимум, максимум)

### Пример
Для временного ряда цен акций [100, 102, 101, 103, 105, 104] и окна размером 3:

\`\`\`
Дата       | Цена | Цена_rolling_mean_3 | Цена_rolling_std_3
-----------|------|---------------------|------------------
01.01.2023 | 100  | NULL                | NULL
02.01.2023 | 102  | NULL                | NULL
03.01.2023 | 101  | 101.0               | 1.0
04.01.2023 | 103  | 102.0               | 1.0
05.01.2023 | 105  | 103.0               | 2.0
06.01.2023 | 104  | 104.0               | 1.0
\`\`\`

### Когда применять
- Для сглаживания временных рядов и выявления трендов
- При создании признаков для моделей прогнозирования
- Для учета локальной динамики временного ряда
- При обработке данных с шумом или высокой волатильностью

<a id="date-components"></a>
## 8. Извлечение компонентов даты

### Описание
Извлекает различные компоненты из столбцов с датами (год, месяц, день недели и т.д.), которые могут быть полезны для выявления сезонности и периодичности в данных.

### Параметры
- **Столбцы с датами для обработки**: столбцы типа datetime
- **Компоненты даты для извлечения**: 
  - Год (year)
  - Месяц (month)
  - Квартал (quarter)
  - День недели (day_of_week)
  - День месяца (day_of_month)
  - День года (day_of_year)
  - Неделя года (week_of_year)

### Пример
Из столбца "Дата" со значением "2023-06-15" можно извлечь:
\`\`\`
Дата_год: 2023
Дата_месяц: 6
Дата_квартал: 2
Дата_день_недели: 4 (четверг)
Дата_день_месяца: 15
Дата_день_года: 166
Дата_неделя_года: 24
\`\`\`

### Когда применять
- Для анализа данных с временной составляющей
- При поиске сезонных паттернов и периодичности
- Для создания признаков, отражающих временные аспекты данных
- Перед построением моделей прогнозирования с учетом сезонности

<a id="inverse-scaling"></a>
## 9. Обратное масштабирование

### Описание
Отменяет эффекты стандартизации или нормализации, возвращая данные к исходному масштабу. Это полезно, когда требуется интерпретировать результаты в исходных единицах измерения.

### Параметры
- **Столбцы для преобразования**: выберите столбцы для обратного масштабирования
- **Параметры масштабирования**: параметры, использованные при первоначальном масштабировании (среднее, стандартное отклонение или мин/макс значения)

### Пример
Если данные были стандартизованы:
- Исходные данные: [10000, 20000, 30000, 40000, 50000]
- Стандартизованные: [-1.41, -0.71, 0, 0.71, 1.41]
- После обратного масштабирования: [10000, 20000, 30000, 40000, 50000]

### Когда применять
- После применения масштабирования и прогнозирования, когда нужно вернуть результаты к исходному масштабу
- Для интерпретации результатов в понятных единицах измерения
- При визуализации данных в исходном масштабе
- При экспорте обработанных данных для внешнего использования

<a id="recommended-sequence"></a>
## 10. Рекомендуемые последовательности методов

### Для обычных табличных данных
1. **Обработка пропущенных значений**
2. **Обработка выбросов**
3. **Извлечение компонентов даты** (если есть даты)
4. **Кодирование категориальных переменных**
5. **Стандартизация данных**
6. **Снижение размерности (PCA)**

### Для временных рядов
1. **Обработка пропущенных значений**
2. **Извлечение компонентов даты**
3. **Лагирование переменных**
4. **Скользящие статистики**
5. **Обработка выбросов**
6. **Стандартизация данных**

<a id="faq"></a>
## 11. Часто задаваемые вопросы

### Общие вопросы

**Q: Как определить, какие методы предобработки нужны для моих данных?**
A: Система автоматически анализирует загруженные данные и рекомендует подходящие методы предобработки на основе типов данных, наличия пропусков, выбросов и других характеристик.

**Q: Могу ли я сохранить параметры предобработки для последующего использования?**
A: Да, система позволяет экспортировать метаданные масштабирования в формате JSON, которые затем можно импортировать для применения обратного масштабирования или для обработки новых данных.

**Q: Как выбрать оптимальное количество компонент в PCA?**
A: Рекомендуется выбирать такое количество компонент, которое объясняет 80-95% вариации данных. В системе можно задать конкретное число компонент или использовать автоматический выбор на основе объясненной дисперсии.
    `;

    const renderedContent = ref('');
    const activeSection = ref('introduction');
    const contentRef = ref(null);
    const showScrollTop = ref(false);
    const showFeedbackForm = ref(false);
    const feedbackForm = reactive({
      section: '',
      message: ''
    });
    
    // Определение разделов для меню содержания
    const sections = [
      { id: 'introduction', title: 'Введение' },
      { id: 'missing-values', title: '1. Обработка пропущенных значений' },
      { id: 'outliers', title: '2. Обработка выбросов' },
      { id: 'standardization', title: '3. Стандартизация данных' },
      { id: 'categorical-encoding', title: '4. Кодирование категориальных переменных' },
      { id: 'pca', title: '5. Снижение размерности (PCA)' },
      { id: 'lagging', title: '6. Лагирование переменных' },
      { id: 'rolling-statistics', title: '7. Скользящие статистики' },
      { id: 'date-components', title: '8. Извлечение компонентов даты' },
      { id: 'inverse-scaling', title: '9. Обратное масштабирование' },
      { id: 'recommended-sequence', title: '10. Рекомендуемые последовательности' },
      { id: 'faq', title: '11. Часто задаваемые вопросы' }
    ];

    onMounted(() => {
      // Рендеринг Markdown контента
      renderedContent.value = marked(markdownContent);
      
      // Настройка прокрутки
      window.addEventListener('scroll', checkScroll);
    });
    
    onUnmounted(() => {
      window.removeEventListener('scroll', checkScroll);
    });
    
    const checkScroll = () => {
      showScrollTop.value = window.scrollY > 300;
      updateActiveSection();
    };
    
    const updateActiveSection = () => {
      // Безопасное обновление активного раздела
      sections.forEach(section => {
        const element = document.getElementById(section.id);
        if (element) {
          const rect = element.getBoundingClientRect();
          if (rect.top <= 100) {
            activeSection.value = section.id;
          }
        }
      });
    };
    
    const scrollToSection = (sectionId) => {
      const element = document.getElementById(sectionId);
      if (element) {
        window.scrollTo({
          top: element.offsetTop - 80,
          behavior: 'smooth'
        });
      }
    };
    
    const scrollToTop = () => {
      window.scrollTo({
        top: 0,
        behavior: 'smooth'
      });
    };
    
    const provideFeedback = (positive) => {
      if (positive) {
        ElMessage({
          message: 'Спасибо за положительный отзыв!',
          type: 'success'
        });
      }
    };
    
    const submitFeedback = () => {
      if (!feedbackForm.section || !feedbackForm.message) {
        ElMessage({
          message: 'Пожалуйста, заполните все поля',
          type: 'warning'
        });
        return;
      }
      
      // В реальном приложении здесь был бы запрос к API
      ElMessage({
        message: 'Спасибо за ваш отзыв! Мы учтем его при обновлении документации.',
        type: 'success',
        duration: 3000
      });
      
      showFeedbackForm.value = false;
      feedbackForm.section = '';
      feedbackForm.message = '';
    };

    return {
      renderedContent,
      activeSection,
      sections,
      showScrollTop,
      contentRef,
      scrollToSection,
      scrollToTop,
      provideFeedback,
      showFeedbackForm,
      feedbackForm,
      submitFeedback
    };
  }
});
</script>

<style scoped>
.help-view {
  max-width: 1200px;
  margin: 0 auto;
  padding: 20px;
}

.help-card {
  margin-bottom: 20px;
}

.help-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.help-header h1 {
  margin: 0;
  font-size: 28px;
  color: #333;
}

.table-of-contents {
  background-color: #f8f9fa;
  border-radius: 4px;
  padding: 15px;
  margin-bottom: 20px;
  border-left: 4px solid #409eff;
}

.table-of-contents h2 {
  margin-top: 0;
  color: #409eff;
}

.toc-menu {
  border-right: none;
}

.toc-menu .el-menu-item {
  padding: 0 15px;
  height: 36px;
  line-height: 36px;
}

.toc-menu .el-menu-item.is-active {
  color: #409eff;
  font-weight: bold;
}

.help-content {
  padding: 20px 0;
  line-height: 1.7;
}

/* Стили для Markdown контента */
.help-content :deep(h1) {
  font-size: 28px;
  font-weight: bold;
  margin-bottom: 20px;
  color: #303133;
  border-bottom: 2px solid #409eff;
  padding-bottom: 10px;
}

.help-content :deep(h2) {
  font-size: 24px;
  font-weight: bold;
  margin-top: 40px;
  margin-bottom: 20px;
  color: #409eff;
  border-bottom: 1px solid #EBEEF5;
  padding-bottom: 10px;
}

.help-content :deep(h3) {
  font-size: 20px;
  font-weight: bold;
  margin-top: 30px;
  margin-bottom: 15px;
  color: #606266;
}

.help-content :deep(h4) {
  font-size: 18px;
  font-weight: bold;
  margin-top: 20px;
  margin-bottom: 10px;
  color: #606266;
}

.help-content :deep(ul), .help-content :deep(ol) {
  padding-left: 30px;
  margin: 15px 0;
}

.help-content :deep(li) {
  margin-bottom: 10px;
}

.help-content :deep(p) {
  line-height: 1.7;
  margin-bottom: 15px;
  color: #606266;
}

.help-content :deep(pre) {
  background-color: #f5f7fa;
  padding: 15px;
  border-radius: 4px;
  overflow-x: auto;
  margin: 15px 0;
  font-family: 'Consolas', 'Monaco', monospace;
}

.help-content :deep(code) {
  font-family: 'Consolas', 'Monaco', monospace;
  background-color: #f5f7fa;
  padding: 2px 4px;
  border-radius: 3px;
  font-size: 0.9em;
}

.help-content :deep(table) {
  width: 100%;
  border-collapse: collapse;
  margin: 20px 0;
}

.help-content :deep(th), .help-content :deep(td) {
  border: 1px solid #dcdfe6;
  padding: 12px 15px;
  text-align: left;
}

.help-content :deep(th) {
  background-color: #f5f7fa;
  color: #606266;
  font-weight: bold;
}

.help-content :deep(tr:nth-child(even)) {
  background-color: #fafafa;
}

.help-content :deep(a) {
  color: #409eff;
  text-decoration: none;
}

.help-content :deep(a:hover) {
  text-decoration: underline;
}

.feedback-container {
  margin-top: 40px;
  padding: 20px;
  background-color: #f8f9fa;
  border-radius: 4px;
  text-align: center;
}

.feedback-buttons {
  display: flex;
  justify-content: center;
  gap: 15px;
  margin-top: 15px;
}

@media (max-width: 768px) {
  .help-header h1 {
    font-size: 24px;
  }
  
  .feedback-buttons {
    flex-direction: column;
  }
}
</style>